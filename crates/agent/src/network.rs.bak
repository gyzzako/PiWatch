use crate::api_client::{ApiClient};
use netlink_packet_route::{
    address::AddressAttribute,
    address::AddressMessage,
    RouteNetlinkMessage,
};
use netlink_packet_core::{NetlinkPayload,NetlinkMessage};
use rtnetlink::new_connection;
use futures::StreamExt;
use std::{
    net::{IpAddr, Ipv4Addr}
};
use anyhow::{Result, Context};
use futures_channel::mpsc::UnboundedReceiver;
use netlink_sys::SocketAddr;

pub(crate) struct IpChangeListener {
    last_ip: Option<String>,
    api: ApiClient,
    link_index: u32,
    messages: UnboundedReceiver<(NetlinkMessage<RouteNetlinkMessage>, SocketAddr)>,
}

impl IpChangeListener {
    const INTERFACE: &'static str = "eth0";

    pub(crate) async fn start(api: ApiClient) -> Result<tokio::task::JoinHandle<Result<(), anyhow::Error>>> {
        let listener = Self::init(api)
            .await
            .with_context(|| "Failed to subscribe to IP changes")?;

        let handle = tokio::spawn(async move {
            match listener.run().await {
                Ok(()) => Ok(()),
                Err(e) => {
                    eprintln!("IP change listener stopped: {e}");
                    Err(e)
                }
            }
        });
        
        Ok(handle)
    }

    async fn init(api: ApiClient) -> Result<Self> {
        let (connection, handle, messages) = new_connection()?;
        tokio::spawn(connection);

        // resolve interface
        let mut links = handle
            .link()
            .get()
            .match_name(Self::INTERFACE.to_string())
            .execute();

        let link = links
            .next()
            .await
            .ok_or_else(|| anyhow::anyhow!("interface not found"))??;

        let link_index = link.header.index;

        Ok(Self {
            last_ip: None,
            api,
            link_index,
            messages
        })
    }
    
    async fn run(mut self) -> Result<()> {
        while let Some((msg, _)) = self.messages.next().await {
            let NetlinkPayload::InnerMessage(inner) = msg.payload else {
                continue;
            };

            let (addr, event) = match inner {
                RouteNetlinkMessage::NewAddress(a) => (a, "add"),
                RouteNetlinkMessage::DelAddress(a) => (a, "del"),
                _ => continue,
            };

            if addr.header.index != self.link_index {
                continue;
            }

            let Some(ip) = self.extract_ipv4(&addr).map(|ip| ip.to_string()) else {
                continue;
            };

            if self.last_ip.as_deref() == Some(&ip) {
                continue;
            }

            self.last_ip = Some(ip.clone());

            if let Err(e) = self.api.update_ip(
                "node_id_placeholder".to_string(),
                ip,
                event.to_string(),
            ).await {
                eprintln!("Failed to report IP change: {e}");
            }
        }

        Err(anyhow::anyhow!("IP changes subscription ended"))
    }

    fn extract_ipv4(&self, msg: &AddressMessage) -> Option<Ipv4Addr> {
        for attr in &msg.attributes {
            if let AddressAttribute::Address(ip) = attr {
                if let IpAddr::V4(v4) = ip {
                    return Some(*v4);
                }
            }
        }
        None
    }
}